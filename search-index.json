[{"slug":"a-brief-history-of-ruby-on-rails","title":"A Brief History of Ruby on Rails","description":"During the development of the Basecamp project management tool in 2003, David Heinemeier Hansson created a Ruby-based web development framework. This framework, later named Ruby on Rails (RoR), was designed to streamline the development process and accelerate the creation of web applications. Released as open-source in 2004, Ruby on Rails rapidly gained traction within the developer community. Its \"convention over configuration\" philosophy, combined with powerful features like scaffolding and ActiveRecord, made it a compelling choice for building web applications.","tags":["ruby","ruby on rails"],"image":"/images/ror_history.webp","content":"\n![Ruby on Rails](/images/ror_history.webp \"Ruby on Rails\")\n\n# A Brief History of Ruby on Rails: From Niche to Mainstream\n\n\n*Published on: 2024-08-23*\n\n**The Birth of Ruby**\n\n[Ruby](/posts/a-brief-history-of-ruby), a dynamic, object-oriented programming language, emerged from the mind of Yukihiro Matsumoto (Matz) in 1995. Inspired by languages like Perl, Python, and Smalltalk, Matz sought to create a language that was both natural and powerful. Ruby's emphasis on programmer happiness and productivity quickly garnered a dedicated following.\n\n\n**The Rise of Ruby on Rails**\n\nDuring the development of the Basecamp project management tool in 2003, <a href=\"https://en.wikipedia.org/wiki/David_Heinemeier_Hansson\">David Heinemeier Hansson</a> created a Ruby-based web development framework. This framework, later named <a href=\"https://rubyonrails.org/\" target=\"_blank\">Ruby on Rails</a> (RoR), was designed to streamline the development process and accelerate the creation of web applications.\n\n\n![A Brief History of ror](/images/image-2a.webp \"A Brief History of ror\")\n\n\n**The Ruby on Rails Revolution**\n\nReleased as open-source in 2004, Ruby on Rails rapidly gained traction within the developer community. Its \"convention over configuration\" philosophy, combined with powerful features like scaffolding and ActiveRecord, made it a compelling choice for building web applications.\n\n\n**Key Factors in Ruby on Rails' Success**\n\n- **Speed and Productivity:** Ruby on Rails' focus on rapid development and clean code led to significant time savings for developers.\n- **Community and Ecosystem:** A vibrant and supportive community of Ruby on Rails developers contributed to its growth and the availability of a rich ecosystem of gems (libraries).\n- **Flexibility:** While Rails promotes conventions, it also offers flexibility for customization when needed.\n- **Full-Stack Framework:** Ruby on Rails provides a comprehensive set of tools for building web applications, from the database to the user interface.\n\n\n![A Brief History of ror](/images/image-2b.webp \"A Brief History of ror\")\n\n\n**Ruby on Rails Today**\n\nRuby on Rails continues to be a popular choice for web development projects, particularly those that emphasize rapid prototyping and iterative development. It has been used to build various applications, from startups to large-scale enterprise systems. While newer frameworks have emerged, Ruby on Rails remains a cornerstone of the web development landscape due to its proven track record, strong community, and ongoing evolution."},{"slug":"a-brief-history-of-ruby","title":"A Brief History of Ruby","description":"Ruby’s story is a fascinating chronicle of evolution, community, and the profound impact of a visionary creator. Born in Japan in 1993, Yukihiro “Matz” Matsumoto envisioned a language that was both powerful and enjoyable to work with. Inspired by Smalltalk and Perl, Matz sought to create a programming language that prioritizing programmer happiness and productivity.","tags":["ruby"],"image":"/images/ruby_history.webp","content":"\n\n![A Brief History of Ruby](/images/ruby_history.webp \"A Brief History of Ruby\")\n\n# A Brief History of Ruby\n\n*Published on: 2024-08-09*\n\nRuby's story is a fascinating chronicle of evolution, community, and the profound impact of a visionary creator. Born in Japan in 1993, <a href=\"https://en.wikipedia.org/wiki/Yukihiro_Matsumoto\" target=\"_blank\">Yukihiro \"Matz\" Matsumoto</a> envisioned a language that was both powerful and enjoyable to work with. Inspired by Smalltalk and Perl, Matz sought to create a programming language that prioritizing programmer happiness and productivity.\n\nInitially released in 1993, <a href=\"https://www.ruby-lang.org/\" target=\"_blank\">Ruby</a> quickly garnered a dedicated following in Japan, thanks to its free and open-source nature. Ruby was still in its infancy when Ruby 1.0 was released in December 1996. This was quickly followed by Ruby 1.1 in August 1997 and the first stable version, Ruby 1.2, in December 1998. While Ruby had a dedicated following in Japan at this time, it was yet to gain significant traction outside of the country. It is still possible to download the infant version of Ruby <a href=\"https://ftp.ruby-lang.org/pub/ruby/1.0/\" target=\"_blank\">here</a>.\n \n\nHowever, it wasn't until the emergence of <a href=\"https://rubyonrails.org/\" target=\"_blank\">Ruby on Rails</a> in 2004 that Ruby truly gained global recognition. <a href=\"https://en.wikipedia.org/wiki/David_Heinemeier_Hansson\">David Heinemeier Hansson</a>, frustrated with the limitations of existing web development tools, created Rails, a framework that offered a rapid development environment, revolutionizing the way web applications were built.\n\nThe widespread adoption of Ruby on Rails ignited a surge of developers and enthusiasts in the Ruby community. Open-source libraries, known as \"gems,\" began flourishing, expanding Ruby's capabilities and simplifying web development. Ruby's versatility soon extended beyond web development, finding applications in data analysis, automation, scripting, and game development.\n\nThroughout its evolution, Ruby has consistently adapted to the changing technological landscape, receiving regular updates and new features. Its emphasis on readability, expressiveness, and a welcoming community has made it a beloved language for millions of developers worldwide.\n\n![A Brief History of Ruby](/images/image-1a.webp \"A Brief History of Ruby\")\n\n**Key Takeaways from Ruby's History:**\n- **Programmer Happiness First:** Ruby was designed with the developer's experience in mind, prioritizing readability, expressiveness, and joy in coding.\n- **Open Source Innovation:** Ruby's open-source nature fostered a thriving community and the creation of a vast ecosystem of tools and libraries.\n- **Versatility Beyond Web Development:** Ruby has proven its adaptability in various domains, demonstrating its versatility and power.\n- **The Impact of a Visionary:** Matz's passion and dedication to creating a language that prioritized developer happiness have had a lasting impact on the tech world.\n\n![A Brief History of Ruby](/images/image-2a.webp \"A Brief History of Ruby\")\n\nRuby's journey is a testament to the power of community, innovation, and a developer's unwavering commitment to creating something beautiful and useful. It's a language that continues to evolve and inspire, leaving an enduring mark on the world of software development.\n\n"},{"slug":"hotwire-and-view-components-a-basic-to-do-list","title":"Hotwire and View Components: A basic \"to-do list\"","description":"Let's build a simple to-do list application without using a single line of javascript. We'll utilize Turbo for interactive list updates and View Components to encapsulate the task creation and display elements.","tags":["hotwire","view component","ruby on rails"],"image":"/images/hotwire_todo.webp","content":"![Hotwire, A basic to-do list](/images/hotwire_todo.webp \"Hotwire, A basic to-do list\")\n\n**Hotwire and View Components: A basic \"to-do list\"**\n\n*Published on: 2024-08-02*\n\n**Building a To-Do List Application**\n\nLet's build a simple to-do list application without using a single line of javascript. We'll utilize Turbo for interactive list updates and View Components to encapsulate the task creation and display elements.\n\nFor this application, we’ll use the following stack:\n\n- Ruby on Rails 7.x\n- Hotwire (Turbo)\n- Sqlite\n- Tailwind CSS\n\n1. Setting up the Rails Project. Begin by creating a new Rails project:\n\n```bash\nrails new todolist -T -M\n```\n\n2. Install Tailwind CSS\n\n    It would be very beneficial to consider Tailwind CSS over plain CSS or SASS for its dramatic impact on CSS maintainability and UI design productivity.\n\n    First, install the *tailwindcss-rails gem*\n\n```bash\nbundle add tailwindcss-rails\n```\n\n run the Tailwind installer, which will set up Tailwind:\n\n ```bash\nrails tailwindcss:install\n```\n\nNext, configure the template paths in the config/tailwind.config.js file. Using these files, Tailwind generates the final CSS. \n\n```javascript\nconst defaultTheme = \n      require('tailwindcss/defaultTheme')\n\nmodule.exports = {\n  content: [\n    './public/*.html',\n    './app/helpers/**/*.rb',\n    './app/javascript/**/*.js',\n    './app/views/**/*.{erb,haml,html,slim}',\n    './app/components/**/*.{erb,haml,html,slim}'\n  ],\n  theme: {\n    extend: {\n      fontFamily: {\n        sans: ['Inter var', \n                ...defaultTheme.fontFamily.sans],\n      },\n    },\n  },\n  plugins: [\n    require('@tailwindcss/forms'),\n    require('@tailwindcss/typography'),\n    require('@tailwindcss/container-queries'),\n  ]\n}\n```\n\n3. Creating the Todo Model\n\n```bash\nrails g model Todo task:string completed:boolean\n```\n\nrun migrations:\n\n```bash\nrails db:migrate\n```\n\n4. Designing the View Component\n\nAdd view component support:\n\n```bash\nbundle add view_component\n```\n\nCreate a View Component:\n\n```bash\nrails generate component Todolist::Item\n```\n\nAfter running the command, you might end up with:\n\n```bash\napp/\n└── components/\n    └── todolist/\n        ├── item_component.html.erb\n        └── item_component.rb\n```\n\n\n5. Implementing the View Component\n\nDefine the necessary logic in item_component.rb:\n\n```ruby\nmodule Todolist\n  class ItemComponent < ViewComponent::Base\n    def initialize(todo:)\n      super\n      @todo = todo\n    end\n  end\nend\n```\n\nMake the following changes to item_component.html.erb:\n\n```html\n<div id=\"todo_<%= @todo.id %>\">\n  <%= form_with model: @todo, remote: true, \n      html: { id: dom_id(@todo), \n              class: \"flex gap-4 pt-6 \n                      items-center\" } \n      do |form| %>\n\n    <%= form.label :completed, \"Completed\", \n        class: \"sr-only\", \n        for: \"completed_#{dom_id(@todo)}\" %>\n    <%= form.check_box :completed, \n        id: \"completed_#{dom_id(@todo)}\", \n        class: 'size-6' %>\n    \n    <%= form.label :task, \"Task\", \n        class: \"sr-only\", \n        for: \"task_#{dom_id(@todo)}\" %>\n    <%= form.text_field :task, \n        id: \"task_#{dom_id(@todo)}\", \n        class: 'rounded-xl w-full md:w-auto' %>\n\n    <%= form.submit 'Update', \n        class: 'bg-blue-300 p-2 rounded-xl \n                cursor-pointer hover:bg-gray-400\n                w-fit text-center w-auto' %>\n\n    <%= link_to 'Delete', todo_path(@todo), \n        method: :delete, title: 'Delete', \n        data: { turbo_confirm: 'Are you sure?', \n                turbo_method: :delete }, \n        class: 'bg-red-400 p-2 rounded-xl \n                cursor-pointer hover:bg-gray-400 \n                w-fit text-center w-auto' %>\n  <% end %>\n</div>\n```\n\nThis code generates a form for each to-do item on your list. It allows you to edit the task, mark it as complete or delete it, all while providing a smooth user experience with AJAX updates.\n\n![alt text](/images/post4/image1.png)\n\nIn essence:\n- You've enabled AJAX with remote: true.\n- You've provided instructions for Turbo on the client-side.\n- Your server-side code now needs to handle the AJAX request and send back the right content to enable the seamless update.\n\n\n6. Creating the todos view\n\nFirst, update the config/routes.rb to:\n\n```ruby\nRails.application.routes.draw do\n  resources :todos, except: %i[edit show new]\n  root 'todos#index'\nend\n```\n\nadd the file app/views/todos/index.html.erb:\n\n\n```html\n<div class=\"flex flex-col gap-4\">\n  <h1 class=\"font-bold\">Todo List</h1>\n\n  <%= render 'form' %>\n  \n  <div id=\"messages\" class=\"text-red-500\"></div>\n\n  <div id=\"todos\" class=\"pr-8 flex flex-col\">\n    <% @todos.all.each do |todo|  %>\n      <%= render \n          Todolist::ItemComponent.new(todo: todo) \n      %>\n    <% end %>\n  </div>\n</div>\n```\n\nthe _form.html.erb partial is defined as follows:\n\n\n```html\n<%= form_with \n    model: Todo.new, \n    url: todos_path, \n    local: true, \n    id: 'form', \n    class: 'flex gap-4', \n    autocomplete: false, \n    html: {  autocomplete: \"off\" } do |f| %>\n  <%= f.label :task, 'Task', class: 'sr-only' %>\n  <%= f.text_field :task, \n      placeholder: 'New task', \n      class: 'rounded-xl' %>\n  <%= f.submit 'Add', \n      class: 'bg-gray-300 p-2 rounded-xl \n              cursor-pointer hover:bg-gray-400' \n      %>\n<% end %>\n```\n\n7. Adding the Controller\n\nCreate a `TodosController`:\n\n```bash\nrails generate controller TodosController\n```\n\nthis generates todos_controller.rb:\n\n```ruby\nclass TodosController < ApplicationController\n  before_action :set_todo, only: %i[update destroy]\n\n  def index\n    @todos = Todo.all\n  end\n\n  def create\n    @todo = Todo.new(todo_params)\n    if @todo.save\n      render turbo_stream: [\n        turbo_stream.append('todos', \n          Todolist::ItemComponent.new(todo: \n          @todo)),\n        turbo_stream.replace('form', \n          partial: 'todos/form'),\n        turbo_stream.update('messages', '')]\n    else\n      render_error_response\n    end\n  end\n\n  def update\n    if @todo.update(todo_params)\n      render turbo_stream: [\n        turbo_stream.replace(\"todo_#{@todo.id}\", \n          Todolist::ItemComponent.new(todo: \n          @todo)),\n        turbo_stream.update('messages', \n          'Task was successfully updated.')]\n    else\n      render_error_response\n    end\n  end\n\n  def destroy\n    @todo.destroy\n    render turbo_stream: \n      turbo_stream.remove(\"todo_#{@todo.id}\")\n  end\n\n  private\n\n  def render_error_response\n    @errors = @todo.errors.full_messages.join(', ')\n    render turbo_stream: \n      turbo_stream.update('messages', @errors)\n  end\n\n  def set_todo\n    @todo = Todo.find(params[:id])\n  end\n\n  def todo_params\n    params.require(:todo).permit(:task, :completed)\n  end\nend\n```\n\n\n**Interaction Flow:**\n\n1. Initial Page Load: The index action renders the page with the list of tasks.\n\n2. Creating a new task:\n- User fills out the form and submits it.\n- The create action handles the request, saves the task, and sends back Turbo Stream instructions to:\n    - Render only the new task (view component) to the list.\n    - Reset the form.\n    - Clear any messages.\n\n![alt text](/images/post4/image2.gif)\n\n![alt text](/images/post4/image3.png)\n\n\n3. Updating a task:\n\n  - User interacts with the form within an item (e.g., checks the \"Completed\" checkbox or updates the task text).\n  - The form submits the changes using AJAX (due to remote: true).\n  - The update action processes the update and responds with Turbo Stream instructions to:\n      - Replace the existing item only with the updated version.\n      - Display a success message.\n\n![alt text](/images/post4/image4.gif)\n\n\n\n4. Deleting a task:\n  - The user clicks \"Delete\".\n  - The link's data attributes trigger a confirmation dialog (using turbo_confirm) and specify the delete method.\n  - The destroy action handles the deletion and sends back a Turbo Stream instruction to remove the item from the DOM.\n\n\n\n  **Benefits of this Approach:**\n  - **Improved User Experience:** Turbo Streams provide a seamless and responsive experience for users by updating specific parts of the page without full-page reloads.\n\n  - **Code Organization:** ViewComponents encapsulate the presentation logic for individual todo items, making the code more modular and maintainable.\n\n  - **Reduced Data Transfer:** Turbo Streams optimize performance by transmitting only the necessary HTML fragments, reducing bandwidth consumption and improving page load times. They also offer several actions for manipulating content on a web page, allowing for efficient updates without full page reloads. These actions include:\n    - Append: Adds new content to an existing element.\n    - Replace: Replaces the content of a target element with new content.\n    - Update: Modifies the attributes or properties of an existing element.\n    - Remove: Deletes a specific target element from the page.\n    - Prepend: Inserts new content before the target element.\n    - After: Inserts new content after the target element.\n\n\n\n# Conclusion\n\nHotwire and View Components in Rails 7 create a powerful combination for building modern web applications. This duo leverages Hotwire's server-driven approach and View Components' modularity to deliver dynamic and engaging user experiences, while maintaining a clean and efficient codebase. This approach not only improves the user experience but also streamlines development by:\n\n  - **Enhancing Code Maintainability:** View Components create modular and reusable building blocks, making code more organized and easier to understand.\n\n  - **Boosting Development Speed:** Hotwire minimizes the need for complex JavaScript, allowing for faster development cycles.\n\n  - **Optimizing Performance:** Turbo Streams ensure efficient data transfer, leading to improved performance and a smoother user experience.\n\n"},{"slug":"hotwire-and-view-components-a-modern-rails-workflow","title":"Hotwire and View Components: A Modern Rails Workflow","description":"We can take advantage of two powerful features in Rails 7 to significantly enhance development speed and user experience: Hotwire and View Components.","tags":["hotwire","view component","ruby on rails"],"image":"/images/hotwire_viewcomponents.webp","content":"![alt text](/images/hotwire_viewcomponents.webp \"Title\")\n\n**Hotwire and View Components: A Modern Rails Workflow**\n\n*Published on: 2024-07-29*\n\nWe can take advantage of two powerful features in Rails 7 to significantly enhance development speed and user experience: Hotwire and View Components. While each offers unique benefits, together they form a dynamic duo for building modern, interactive web applications.\n\nThis article will explore both concepts through a practical example, building a simple application showcasing their integration. In the [next post](/posts/hotwire-and-view-components-a-basic-to-do-list), we'll create a basic \"to-do list\" application with Hotwire's Turbo functionality for seamless page updates and View Components to encapsulate reusable UI elements.\n\n\n![Hotwire and View Components](/images/image-3a.webp \"Hotwire and View Components\")\n\n**Hotwire: Bridging the Gap Between Server and Client**\n\nHotwire, encompassing technologies like Turbo and Stimulus, provides a server-driven approach to building interactive experiences. Unlike traditional JavaScript frameworks that rely heavily on client-side rendering, Hotwire leverages the power of Rails' server-side rendering, minimizing the need for complex JavaScript code.\n\n- **Turbo** serves as the foundation for Hotwire, enabling seamless page updates without full page reloads. When a user interacts with the application, Turbo handles the communication between the server and client, replacing only the necessary sections of the page, resulting in a faster and smoother experience.\n\n- **Stimulus** complements Turbo by offering a lightweight JavaScript framework for enhancing page elements with dynamic behavior. It allows you to write concise JavaScript code, directly interacting with HTML elements and handling user interactions.\n\n![Hotwire and View Components](/images/image-3b.webp \"Hotwire and View Components\")\n\n\n**View Components: Building Reusable UI Blocks**\n\nView Components introduce the concept of reusable UI building blocks, encapsulating logic and presentation into self-contained components. This promotes code reusability, maintainability, and consistency across your application.\n\nEach View Component represents a specific UI element, such as a form, a list, or a navigation menu. It has its own dedicated view file, controller logic, and optional helper methods, allowing for tailored functionality and presentation.\n\n![Hotwire and View Components](/images/image-3c.webp \"Hotwire and View Components\")"},{"slug":"timet-a-powerful-command-line-tool-for-tracking-your-time","title":"Timet","description":"Timet is a command line time tracking gem with time reports. Using it, you can keep track of how much time you spend on various activities. It's simple to track your hours for work with timet, whether you're curious about how you allocate your time.","tags":["ruby","timet"],"image":"/images/timet.webp","content":"\n![Timet](/images/timet.webp \"Timet\")\n\n## Timet: A Powerful Command Line Tool for Tracking Your Time\n\n[![Gem Version](https://badge.fury.io/rb/timet.svg)](https://github.com/frankvielma/timet)\nTimet is a Ruby-based command-line tool designed for professionals to track time spent on multiple tasks. It offers a simple, efficient interface to start, stop, and manage time tracking, with data stored locally using SQLite. Timet helps improve productivity and billing accuracy by providing detailed reports and summaries for tracked tasks, making it ideal for developers, freelancers, and project managers seeking an easy-to-use time management solution.\n\n### Why Timet?\n\n**Timet** is designed to track the time you spend on various tasks locally, without relying on external databases or cloud storage. It uses **SQLite** to store the time tracking data, ensuring that your data remains secure and private. With Timet, you get:\n\n**Key Features:**\n\n- **Local Data Storage:** Timet utilizes SQLite to store your time tracking data locally, ensuring privacy and security.\n- **Lightweight and Fast:** Its efficient design and local data storage make Timet a speedy and responsive tool.\n- **Structured Data:** SQLite ensures your data is organized and easily accessible.\n- **Scalability:** Timet can handle growing time tracking needs.\n- **Data Integrity:** SQLite maintains the accuracy and consistency of your data.\n- **Querying and Reporting:** Generate detailed reports for specific periods.\n- **CSV Export:** Easily export your time tracking data to CSV format for further analysis or sharing.\n\n### Getting Started with Timet\n\nTimet requires Ruby version 3.0.0 or greater and sqlite3 version 1.7 or above to function properly. There are alternative installations for older Ruby and Sqlite versions as well.\n\n#### Installation\n\nYou can install Timet directly using the gem command:\n\n```bash\ngem install timet\n```\n\n### Using Timet\n\nTimet offers a straightforward command-line interface for tracking your time. Here's a breakdown of some essential commands:\n\n- **Start Tracking Time:**\n\n  Use the `timet start task1 --notes='Meeting with client'` command to begin tracking time for a specific task using a note (optional).\n\n  For instance, to start tracking time for a task named \"task1\", you would run:\n\n  ```bash\n  timet start task1 --notes='Meeting with client'\n  ```\n\n- **Stop Tracking Time:**\n\n  To stop tracking the current task and record the elapsed time, use the `timet stop` command. This will also display a report summarizing the total time spent on all tasks.\n\n- **Resume Tracking:**\n\n  If you need to pause your work and then pick up where you left off, the `timet resume` command allows you to resume tracking a previously stopped task.\n\n- **View Time Reports:**\n\n  Timet offers various options for generating time reports:\n\n  | Command        | Description                                        |\n  | -------------- | -------------------------------------------------- |\n  | **timet su t** | Get a report of tracked time for the current day.  |\n  | **timet su y** | View a report of tracked time for yesterday.       |\n  | **timet su w** | See a report of tracked time for the entire week.  |\n  | **timet su r** | Resume tracking the last task you were working on. |\n  | **timet su m** | View a report for the previous month.              |\n\n- **Export Time Reports to CSV:**\n\n  The summary command has the option to export your time data to a CSV file by specifying the --csv flag. For example:\n\n  ```bash\n  timet su t --csv=file.csv\n  ```\n\n  This will create a CSV file (summary_today.csv) containing all tracked tasks for the current day, making it easy to share or import into other tools. You can use this flag with any of the summary filters (t, y, w, m).\n\n  When exporting to CSV, timestamps for start and end times are converted to a readable date format (YYYY-MM-DD HH:MM:SS), ensuring compatibility with software like Excel or LibreOffice.\n\n- **Delete Tasks:**\n\n  The `timet d [id]` command allows you to remove unwanted tasks. You can find the task ID from the time reports generated using the summary commands.\n\n- **Cancel Tracking:**\n\n  Use `timet c` to stop any active time tracking.\n\n### Conclusion\n\nTimet is a minimalistic tool for time tracking that offers all the necessary features without unnecessary complexity. It empowers developers and professionals to track their tasks with accuracy, all while keeping data secure and local. By leveraging SQLite, it ensures fast data queries, integrity, and a scalable structure, making it a robust solution for time tracking.\n\nIf you're someone who values privacy, control, and ease of use in time tracking, Timet is the perfect companion for your workflow. Give it a try today and take back control of your time!\n"}]